# Седмица 05 - Функции (продължение). Подаване на аргумент по копие и по референция. Връщане на копие или референция

### Стек и стекова рамка

В стековата памет извикванията се базират на принципа LIFO (Last In First Out), или на принципа на абстрактната структура от данни стек. Това поражда и еквивалентния термин **_стекова рамка_** за извикванията на функциите. Най-просто, всяко извикване на една функция обособява **_стекова рамка_** за функцията във стека и заделя своята памет в нея в следната последователност - за параметрите си, return address (адресът на мястото, където ще се върне резултатът), за адреса на предишната стекова рамка и за всичките локални променливи, които тя декларира (включително променливата, която се връща).

```c++
void bar() {}

void foo() {
  bar();
}

int main() {
  foo();
}
```

Кои стекови рамки се намират в стека, във всеки един момент на изпълнение на програмата, са показани на долната картинка:
<img src="https://i.imgur.com/IUGxJPF.jpg" width=100% height=100%>

---

### Какво представляват референциите?

**Референцията** е алтернативно име за съществуваща променлива. Тя действа като псевдоним на променливата и винаги сочи към едно и също място в паметта, към което сочи оригиналната променлива.

Ето някои основни характеристики на референциите:

- След като референцията е свързана с определена променлива, тя не може да сочи към друга променлива. Референцията трябва да се инициализира още при дефиницията.
- Типът на референцията и на променливата, към която сочи, трябва да съвпадат.

- Не може да бъде null (тоест, винаги трябва да сочи към валиден обект в паметта).

```cpp
int main() {
    int x = 10;
    int &ref = x; // ref е референция към x

    ref += 5; // Променяме x чрез ref
    cout << "Стойността на x: " << x << endl; // x става 15
    return 0;
}
```

Тук ref е референция към x. Когато променим ref, променяме и x, тъй като те сочат към едно и също място в паметта.

#### Кога да използваме референции?

- **Когато искаме да избегнем копиране на данни:** Особено полезно при предаване на големи структури, като обекти и масиви, защото така се спестява памет и време.
- **При модификация на оригиналната стойност:** Ако искаме функция да променя оригиналната стойност на променливата, можем да използваме референции.

#### Кога да не използваме референции?

- **Когато искаме да сочим към "нищо" (nullptr):** Референциите трябва винаги да сочат към валиден обект, затова не можем да ги използваме, ако трябва да работим с „празни“ стойности.

- **При нужда от по-голяма гъвкавост:** Ако искаме да сменяме към коя променлива сочим, указателите са по-подходящи.

---

### Какво представляват указателите?

**Указателят** е променлива, която съдържа адреса на друга променлива в паметта. С други думи, той "сочи" към определено място в паметта. Указателите могат да се създават и променят динамично, което ги прави много мощен, но и по-сложен за използване инструмент.

Основни характеристики на указателите:

- **Могат да бъдат null:** Указателите могат да сочат към нищо (nullptr), което позволява по-голяма гъвкавост.
- **Могат да сочат към различни обекти:** Можем да променяме адреса, към който сочи указателят.

```cpp
int main() {
    int x = 10;
    int* p = &x; // p е указател, който сочи към x

    int* p2; // за разлика от референциите тук можем да не даваме стойност

    *p += 5; // Променяме x чрез указателя p
    cout << "x: " << x << endl; // x става 15

    cout << p << endl; // ще принтира адреса, към който сочи указателя
    cout << *p << endl; // 15
    return 0;
}

```

#### Кога да използваме указатели?

- **При работа с динамична памет:** Указателите са необходими за динамично заделяне на памет с операторите `new` и `delete`.
- **Когато искаме да сочим към различни обекти:** Ако искаме да променим към коя променлива сочим, указателите са по-подходящи от референциите.
- **При сложни структури и обработка на данни:** Например в структури от данни като динамични масиви, свързани списъци (linked lists), дървета и графи, указателите са основен инструмент.

#### Кога да не използваме указатели?

- **При прости операции и малки данни:** Използването на указатели може да усложни кода, особено ако няма нужда от динамична памет или манипулация на адреси.
- **Когато не е необходима промяна на адреса:** Ако просто искаме пряк достъп до променлива и няма нужда да променяме към какво сочим, референциите са по-подходящи.

_(но повече по тази тема по - нататък...)_

---

### Подаване на аргументи към функции

Когато предаваме аргументи на функция, имаме три основни начина да го направим:

1. **Подаване по стойност (копие)**

   При подаване по стойност, аргументът, който се подава, се копира в параметъра на функцията. Това означава, че вътре във функцията работим с копие на оригиналната стойност. Ако направим промени върху тази стойност вътре във функцията, те няма да засегнат оригиналната променлива.

   ```cpp
   void increment(int num) {
       ++num; // Променяме локалното копие на num
   }

   int main() {
       int x = 5;
       increment(x);
       cout << "Стойността на x: " << x << endl; // x остава 5
   }
   ```

2. **Подаване чрез референция**

   Когато подаваме аргумент като референция (чрез &), функцията получава пряк достъп до оригиналната променлива, вместо да работи с копие. Това означава, че промените вътре във функцията ще засегнат оригиналната променлива.

   ```cpp
    void increment(int& num) {
        num += 1; // Променяме оригиналната стойност на num
    }

    int main() {
        int x = 5;
        increment(x);
        cout << "x: " << x << endl; // x става 6
    }
   ```

3. **Подаване чрез указател**

   При подаване чрез указател (чрез \*), функцията приема адреса на променливата. За да променим стойността на променливата, използваме оператора \* (дерефериране). Това също позволява на функцията да модифицира оригиналната стойност на променливата, както при подаване чрез референция.

   ```cpp
   void increment(int* num) {
       *num += 1; // Променяме стойността на променливата, към която сочи указателя
   }

   int main() {
       int x = 5;
       increment(&x); // Подаваме адреса на x
       cout << "x: " << x << endl; // x става 6
   }
   ```

---

### Връщане на стойности от функции

Функциите могат да връщат стойности, указатели или референции.

1. **Връщане на стойност (копие)**

   При връщане по стойност, функцията връща копие на резултата. Това означава, че промените, направени върху върнатата стойност извън функцията, няма да засегнат оригиналната променлива.

   ```cpp
   int getValue() {
       int a = 5;
       return a; // Връщаме копие на стойността на a
   }

   int main() {
       int result = getValue(); // getValue() връща rvalue
       cout << result; // 5
       getValue() = 10; // грешка!!
   }a
   ```

2. **Връщане на референция**

   При връщане на референция, функцията връща самия обект или променлива, вместо копие. Това е полезно, когато искаме да запазим ефективността (без излишно копиране) и да променяме оригиналната стойност.

   ```cpp
    int& getValue(int& num) {
        return num; // Връщаме референция към num
    }


    int main() {
        int x = 5;
        getValue(x) = 10; // Променяме директно x чрез върнатата референция, понеже референциите са lvalue
        cout << "x: " << x << endl; // x вече е 10
    }
   ```

   **Важно:** трябва да сте сигурни, че променливата, чиято референция връщате, съществува и след приключването на функцията, тоест да не връщате локално създаден обект.

   ```cpp
   int& errorProne() {
       int a = 5;
       return a;
   }
   //Недефинирано поведение, което компилаторът на Visual Studio, любезно заличава, но реално това е проблем и не всички компилатори го позволяват
   ```

3. **Връщане на указател**

   При връщане на указател функцията връща адрес на променлива, вместо самата стойност. Това също позволява промяна на оригиналната стойност, ако работим с адреса.

   ```cpp
   int* getPointer(int &num) {
       return &num; // Връщаме указател към num
   }

   int main() {
       int x = 5;
       *getPointer(x) = 20; // Променяме стойността на x чрез указателя
       cout << "x: " << x << endl; // x става 20
   }
   ```

Припомняме набързо:

- **lvalue** е стойност, която сочи към определено място в паметта (например променлива). Може да бъде модифицирана, ако не е константна.

- **rvalue** е стойност, която не е обвързана с конкретен адрес (например резултат от израз 5 + 3). Тези стойности не могат да се променят директно и обикновено са временни.

---