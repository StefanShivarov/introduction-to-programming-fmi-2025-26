# Седмица 06 - Mасиви. Подаване на масиви като аргументи на функция. Достъп и търсене на елементи в масив

**Масивите** представляват последователни позиции в паметта, които позволяват съхранението на множество елементи от един и същи тип. Те са подходящи за случаи, в които е необходимо да се работи с множество данни от един и същ тип (например списък с числа или символи).

#### Деклариране

При деклариране на масив, е нужно да се посочи типа и размера му. Размерът на масива трябва да е известно число.

```cpp
int arr[7]; // създава масив със 7 цели числа {0, 0, 0, 0, 0, 0, 0}
```

#### Инициализиране

Масивите могат да се инициализират още при декларацията:

```cpp
int sales[7] = {100, 200, 150, 175, 220, 250, 190};
```

```cpp
int numbers[] = {1, 2, 3, 4, 5, 6} // автоматично задава дължина 6
```

При инициализация, имайте предвид следните неща:

- **Липса на размер при празна инициализация:** Ако не бъде посочен размер и няма зададени стойности, ще възникне грешка.

  ```cpp
  int data[]; // Грешка: компилаторът не знае размера
  ```

- **Големина по-малка от зададените стойности:** Ако инициализирате масив с повече стойности от размера му, ще възникне компилационна грешка.

  ```cpp
  int numbers[2] = {1, 2, 3}; // Грешка: масивът е деклариран за 2 елемента, но има 3 стойности
  ```

- **Големина по-голяма от зададените стойности:** Ако инициализирате масив с по-малко стойности от размера му, компилаторът автоматично ще допълни останалите елементи:

  ```cpp
  int numbers[5] = {1, 2}; // Масивът ще бъде {1, 2, 0, 0, 0}
  ```

---

### Достъп до елементите на масив

В C++ достъпът до елементите в масива става чрез оператора `[]` (оператор за индексиране). Индексът, който поставяме вътре в `[]`, определя позицията на елемента в масива. Трябва да отбележим, че индексите в масивите започват от 0, което означава, че първият елемент има индекс 0, вторият – 1, и т.н.

```cpp
int numbers[3] = {10, 20, 30};
// Достъп до елементите чрез оператора []
cout << numbers[0]; // Извежда 10
cout << numbers[1]; // Извежда 20
cout << numbers[2]; // Извежда 30
```

**Важно:** При използване на оператор `[]`, трябва да внимаваме индексът да е в рамките на размера на масива. Ако се опитаме да достъпим елемент с индекс, който е извън допустимите граници, ще се получи неопределено поведение, което може да доведе до срив на програмата или грешни резултати.

```cpp
cout << numbers[3]; // Грешка: излиза извън границите на масива
```

Това е честа причина за грешки при работа с масиви и може да се избегне, като винаги се проверява дали индексът е в допустимите граници.

---

### Обхождане на масив

```cpp
int sales[5] = {100, 200, 150, 175, 220};
for (int i = 0; i < 5; i++) {
    cout << sales[i] << " "; // 100 200 150 175 220
}
```

Пример за намиране на средноаритметично:

```cpp
int sales[5] = {100, 200, 150, 175, 220};
int total = 0;
for (int i = 0; i < 5; i++) {
    total += sales[i];
}
double average = total / 5.0; // Получаваме средната стойност
cout << "Average sales: " << average << endl;
```
---
**За любознателните:**

Всъщност масивът е просто указател към първия елемент. Тоест един масив `int arr[]` e еквивалентен на `int* arr`. 
В паметта елементите от масива се намират плътно един до друг.
Индексацията всъщност е sugar-syntax за местене на указателя по адресите на елементите в паметта.

`arr[i]` достъпва елемента на индекс 2, но всъщност това е еквивалентно на `*(arr + i)` (тоест отместваме указателя с i адреса надясно и дереферираме). С колко байта ще се отмества указателя, се определя в зависимост от големината на типа елементи, от които е масива (или от типа на указателя).

```cpp
int main() {
    int arr[5] = {1, 2, 3, 4, 5};

    cout << arr << endl; // 0x16f3d2cf0
    cout << arr + 1 << endl; // 0x16f3d2cf4
    cout << arr + 2 << endl; // 0x16f3d2cf8
    cout << arr + 3 << endl; // 0x16f3d2cfc
    cout << arr + 4 << endl; // 0x16f3d2d00

    // Можем да забележим, че указателя се измества през 4 байта,
    // т.е. arr + i измества указателя arr с 4*i (sizeof(int) * i) байта надясно

    cout << arr[0] << endl; // 1
    cout << *arr << endl; // 1

    cout << arr[1] << endl; // 2
    cout << *(arr + 1) << endl; // 2

    cout << arr[2] << endl; // 3
    cout << *(arr + 2) << endl; // 3

    // arr[i] е еквивалентно на *(arr + i)
}
```

---

### Подаване на масиви, като аргументи във функции

```cpp
void printArray(const int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}
```

**Важно:** Когато подаваме масив на функция, всъщност се подава указател към първия елемент на масива, а не копие на целия масив. Това означава, че промените, които се правят върху масива във функцията, ще се отразят върху подадения като параметър масив!

```cpp
#include <iostream>

using namespace std;

// в случая няма значение дали ще подадем int[] или int*
void print(const int* arr, int len) {
	for (int i = 0; i < len; i++) {
		std::cout << arr[i] << " ";
	}
}

void increment(int* arr, unsigned size) {
	for (unsigned i = 0; i < size; i++) {
		arr[i]++;
	}
}


int main() {
	const int SIZE = 4;
	int arr[SIZE]{ 1, 2, 3, 4 };

	increment(arr, SIZE);
	print(arr, SIZE); // 2 3 4 5

	return 0;
}
```
