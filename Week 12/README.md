# Динамична памет. Stack и Heap. Оператори `new` и `delete`. Memory leak

По време на изпълнение всяка C++ програма използва памет (RAM).
Най-важните две области, които ще разглеждаме, са:
- **Stack (стекова памет)**
- **Heap (динамична памет)**

Те се различават по:
- начина на заделяне
- продължителността на живота на данните
- начина на освобождаване на паметта
---

### Стекова памет (Stack)
- predefined size/предварително определен размер
- паметта се заделя по време на компилация на програмата (**compile time**).
- паметта автоматично се освобождава/трие/маркира като свободна - при излизането от scope-а, в който е дефинирана.

В stack-а се пазят:
- локални променливи
- параметри на функции
- самите указатели

```c++
int value = 5; //allocated on the Stack
```

### Пример
```cpp
void f() {
    int value = 5;   // заделя се в stack
}
```

След края на функцията паметта за `value` вече **не е валидна**.

### Честа грешка
```cpp
int* bad() {
    int x = 10;
    return &x; // ❌ указател към stack памет
}
```

Това също води до **dangling pointer**. Върнатият указател ще сочи към вече освободена памет (понеже паметта заделена в стека се зачиства автоматично на края на дадения scope).

---

---
### Динамична памет (Heap)
- паметта се заделя по време на изпълнение на програмата (**runtime**).
- Позволява динамично създаване на масиви и обекти без предварително да е известна големината им.
- няма автоматично освобождаване
- живее, докато не бъде изрично освободена
- по-бавна от stack

Heap паметта се използва, когато:
- размерът на данните не е известен предварително
- данните трябва да живеят по-дълго от един scope

### Пример
```cpp
int* p = new int(5);
```

- `p` в stack
- числото `5` в heap

Схематично:
```
STACK                HEAP
+-----+              +---+
|  p  | -----------> | 5 |
+-----+              +---+
```

---

```c++
int value = 5; //allocated on the Stack
int* p = &value; //pointer allocated on the Stack
int* hValue = new int; //hValue is allocated on the stack
                       //allocates 1 integer on the Heap
*hValue = 5; //dereference to give value to the Heap allocated int

int size;
cin >> size;
int *arr = new int[size]; // dynamically allocated array on the Heap, arr points to the first element of the array, size consecutive ints in heap
```

![Memory](https://dotnettutorials.net/wp-content/uploads/2022/03/word-image-3.png)

---

### Оператор `new`
Операторът `new` заделя динамична памет в heap-а и връща указател към нея.

### Заделяне на единичен обект
```cpp
int* p = new int;
int* q = new int(5);
```

### Заделяне на масив
```cpp
int n;
cin >> n;
int* arr = new int[n];
```

- `n` не е задължително да е константа
- заделянето става по време на изпълнение

Динамичното заделяне е сравнително **бавна операция** и изисква ръчно управление.

---
## Какво означава "освобождаване" на паметта

Освобождаването означава, че:

паметта се отбелязва като свободна

тя може да бъде използвана отново за други данни

стойностите, които са били там, вече не са надеждни

След освобождаване програмата може технически да достъпва тази памет,
но резултатът е непредсказуем.

Достъпът до освободена памет води до **undefined behavior**.

Пример за undefined behaviour:
```cpp
int* ptr = new int(5);
delete ptr;
cout << *ptr;
```

Това се нарича и dangling pointer. Dangling pointer е указател, който сочи към вече освободена памет.

---

## Оператор `delete` и `delete[]`

- Oсвобождава/маркира като свободна динамична памет! <br />
- Зачиства заделените в heap-а елементи
```c++
void f()
{
  int x = 40;
  char ch[2] = {'a', 'b'};
  int* ptr = new int[3];
  delete[] ptr; //free allocated Heap memory
}
```

Динамичната памет **не се освобождава автоматично**.
Ако не бъде освободена, тя остава заета до края на програмата.

### Освобождаване на единичен обект
```cpp
int* p = new int(5);
delete p;
p = nullptr;
```

### Освобождаване на масив
```cpp
int* arr = new int[10];
delete[] arr;
arr = nullptr;
```

Задължително правило:
- за всяко `new` → `delete`
- за всяко `new[]` → `delete[]`

---

## Връщане на масиви от функции

Локални масиви не могат да бъдат връщани от функции.

```cpp
int* bad() {
    int arr[10];
    return arr; // ❌ arr е в stack-а
}
```

### Правилен подход

```cpp
int* createArray(int n) {
    int* arr = new int[n];
    return arr;
}
```

Използване:
```cpp
int* a = createArray(5);
// работа с масива
delete[] a;
```

Кодът, който получава динамичната памет, е отговорен да я освободи.

---

### Memory leak
![Memory-Leak-example](https://www.baeldung.com/wp-content/uploads/2018/11/Memory-_Leak-_In-_Java.png)

След приключването на функцията ще се изчисти паметта в стека, но НЕ и паметта в heap-а. <br />
За това ние трябва ръчно да я маркираме като свободна. <br />
Ако не я изчистим, то ще се получи отечка на памет (**memory leak**). Това става чрез операторите `delete` и `delete[]`.

Memory leak възниква, когато динамично заделена памет:
- не бъде освободена
- и програмата загуби достъп до нея

### Примери

```cpp
void f() {
    int* p = new int(5);
}
```

```cpp
int* p = new int(5);
p = new int(10);
```

```cpp
while (true) {
    int* p = new int(5);
}
```

Memory leak може да доведе до постепенно изчерпване на паметта.

---

## Най-чести грешки

- забравен `delete` след алокиране на динамична памет с `new`
- използване на `delete` вместо `delete[]` при освобождаване на алокирани масиви в динамичната памет
- двойно освобождаване на памет (`delete` директно след `delete` на една и съща памет)
- използване на указател след `delete` (dangling pointer)
- връщане на адрес към stack памет

---